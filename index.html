<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Learning Shooter - Hallway Challenge</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Noto Sans TC', sans-serif; user-select: none; }
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            z-index: 5;
        }
        #hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            color: white; text-shadow: 2px 2px 0 #000; font-size: 24px; font-weight: bold;
        }
        #hud-bottom {
            padding: 20px; color: white; text-shadow: 1px 1px 0 #000; font-size: 18px;
            text-align: center;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            background: transparent;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: red;
            transform: translate(-50%, -50%); border-radius: 50%;
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 10;
        }
        button {
            padding: 15px 30px; font-size: 24px; cursor: pointer;
            background: #4CAF50; color: white; border: none; border-radius: 5px;
            margin-top: 20px;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        .message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ffeb3b; font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px #000;
            opacity: 0; transition: opacity 0.5s;
        }
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s;
            z-index: 4;
        }
        .bar-container {
            width: 200px; height: 20px; background: #333; border: 2px solid white; margin-bottom: 5px;
        }
        #hp-bar { width: 100%; height: 100%; background: #f44336; transition: width 0.2s; }
        
        /* Loading Text */
        #loading { font-size: 20px; color: #aaa; margin-top: 10px; }

        /* MediaPipe Debug View */
        #mediapipe-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 320px; height: 240px;
            border: 2px solid white; background: black;
            z-index: 6; transform: scaleX(-1); /* é¡åƒé¡¯ç¤º */
        }
        #input_video { display: none; }
        #output_canvas { width: 100%; height: 100%; }
        
        .instruction-overlay {
            position: absolute; top: 50%; left: 20px; transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.7); font-size: 14px; pointer-events: none;
            text-align: left;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <!-- Import Map to resolve 'three' dependency -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe Libraries (Switch to Holistic) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- UI Overlay -->
    <div id="damage-overlay"></div>
    <div id="ui-container">
        <div id="hud-top">
            <div>
                <div class="bar-container"><div id="hp-bar"></div></div>
                <div>HP: <span id="hp-text">100</span></div>
            </div>
            <div>å¯¶ç®±: <span id="score-text">0</span> / 3</div>
        </div>
        <div id="message-area" class="message"></div>
        <div id="hud-bottom">
            <div>ç‹€æ…‹: <span id="buff-text" style="color:#00ff00;">ç„¡</span></div>
            <div style="font-size: 14px; color: #ccc;">é ­éƒ¨/éµç›¤ç„æº– | å·¦æ‰‹æ‰‹æŒ‡ç§»å‹• | å³æ‰‹æåˆå°„æ“Š</div>
        </div>
        <div class="instruction-overlay">
            <p>ğŸ™‚ <b>ç„æº– (é ­éƒ¨ + éµç›¤)</b></p>
            <p>é ­éƒ¨è½‰å‘: æ¨¡æ“¬æ–æ¡¿</p>
            <p>æ–¹å‘éµ (â†‘â†“â†â†’): è¼”åŠ©è½‰å‘</p>
            <p>ç©ºç™½éµ (Space): è¦–è§’å›æ­£</p>
            <br>
            <p>ğŸ–ï¸ <b>å·¦æ‰‹ (ç§»å‹•)</b></p>
            <p>â˜ï¸ æŒ‡å‘ä¸Š: å‰é€² | ğŸ‘‡ æŒ‡å‘ä¸‹: å¾Œé€€</p>
            <p>âœŠ æ¡æ‹³: åœæ­¢ç§»å‹•</p>
            <br>
            <p>ğŸ–ï¸ <b>å³æ‰‹ (æ”»æ“Š)</b></p>
            <p>ğŸ‘Œ æåˆ: å°„æ“Š</p>
        </div>
    </div>
    <div id="crosshair"></div>

    <!-- MediaPipe Container -->
    <div id="mediapipe-container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>å–„ç”¨ AI å­¸ç¿’ - é•·å»ŠæŒ‘æˆ°</h1>
        <p>é€™æ˜¯ä¸€æ¢å……æ»¿è€ƒé©—çš„é•·èµ°å»Š</p>
        <p>æ”¶é›†æ²¿é€”çš„ 3 å€‹å–„ç”¨AIåŠ©å­¸ç¿’çš„å¯¶ç®±ï¼Œä¸¦æ“Šæ•—éŒ¯èª¤ä½¿ç”¨AIçš„å®ˆè¡›æ€ªç‰©</p>
        <div id="loading">è¼‰å…¥ç¥ç¶“ç¶²çµ¡æ¨¡å‹ä¸­... (è«‹ç¨å€™)</div>
        <button id="start-btn" style="display:none;">é–‹å•Ÿæ”å½±æ©Ÿä¸¦é–‹å§‹</button>
    </div>

    <!-- Scripts -->
    <script type="module">
        import * as THREE from 'three';

        // --- éŠæˆ²å¸¸æ•¸èˆ‡è®Šæ•¸ ---
        const HALLWAY_WIDTH = 24; 
        const HALLWAY_LENGTH = 200; 
        
        const BAD_HABITS = ["ç›´æ¥æŠ„è¥²", "ä¸åšæŸ¥è­‰", "æ´©éœ²éš±ç§", "ç›²ç›®ç›¸ä¿¡", "éåº¦ä¾è³´", "å¿½è¦–ç‰ˆæ¬Š"];
        const GOOD_HABITS = [
            ["è¼”åŠ©æ€è€ƒè€Œéæ›¿ä»£æ€è€ƒ", "damage", "#00ffff"], ["æª¢æŸ¥ä¾†æºé©—è­‰çœŸç¢º", "damage", "#ff00ff"],
            ["ç”¨æ–¼èªè¨€èˆ‡å¯«ä½œç·´ç¿’", "heal", "#00ff00"], ["æ¿€ç™¼å‰µæ„", "invincible", "#ffd700"],
            ["å¹«åŠ©æ•´ç†èˆ‡ç¸½çµ", "heal", "#00ff00"]
        ];

        let camera, scene, renderer;
        
        // æ“æ§è®Šæ•¸
        let handMoveForward = false, handMoveBackward = false, handMoveLeft = false, handMoveRight = false;
        let headLookYaw = 0;   
        let headLookPitch = 0; 
        let isPinching = false;
        let wasPinching = false;
        
        // éµç›¤è¦–è§’æ§åˆ¶è®Šæ•¸
        let keyLookUp = false, keyLookDown = false, keyLookLeft = false, keyLookRight = false;

        let prevTime = performance.now();
        let isGameOver = false; 
        let isGameActive = false; 
        let chestsCollected = 0; 
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        const bullets = [];
        const enemies = [];
        const chests = [];
        const collidableMeshList = []; 
        
        const player = {
            hp: 100, maxHp: 100, score: 0,
            speedMultiplier: 1.0, damageMultiplier: 1.0,
            isInvincible: false, height: 1.6
        };

        // --- MediaPipe Holistic åˆå§‹åŒ– ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        let cameraUtils = null;

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            const w = canvasElement.width;
            const h = canvasElement.height;
            canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            canvasCtx.lineWidth = 1;
            canvasCtx.beginPath(); canvasCtx.moveTo(w / 2, 0); canvasCtx.lineTo(w / 2, h); canvasCtx.stroke();
            canvasCtx.beginPath(); canvasCtx.moveTo(0, h / 2); canvasCtx.lineTo(w, h / 2); canvasCtx.stroke();

            handMoveForward = false; handMoveBackward = false;
            handMoveLeft = false; handMoveRight = false;
            headLookYaw = 0; headLookPitch = 0;
            isPinching = false;

            // 1. é ­éƒ¨è¿½è¹¤
            if (results.faceLandmarks) {
                const nose = results.faceLandmarks[1];
                const nx = nose.x * canvasElement.width;
                const ny = nose.y * canvasElement.height;
                canvasCtx.beginPath(); canvasCtx.arc(nx, ny, 5, 0, 2 * Math.PI); canvasCtx.fillStyle = "yellow"; canvasCtx.fill();

                const deadzone = 0.05;
                if (nose.x < 0.5 - deadzone) headLookYaw = 1.2 * (0.5 - deadzone - nose.x) * 10; 
                else if (nose.x > 0.5 + deadzone) headLookYaw = -1.2 * (nose.x - 0.5 - deadzone) * 10;
                
                if (nose.y < 0.5 - deadzone) headLookPitch = -0.4 * (0.5 - deadzone - nose.y) * 10; 
                else if (nose.y > 0.5 + deadzone) headLookPitch = 0.4 * (nose.y - 0.5 - deadzone) * 10; 
            }

            // 2. å·¦æ‰‹ (ç§»å‹•)
            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.leftHandLandmarks, {color: '#00FF00', lineWidth: 1});

                const wrist = results.leftHandLandmarks[0];
                const indexTip = results.leftHandLandmarks[8];
                const dx = indexTip.x - wrist.x;
                const dy = indexTip.y - wrist.y;
                const dist = Math.hypot(dx, dy);
                const fistThreshold = 0.08; 

                if (dist < fistThreshold) {
                    // æ¡æ‹³ç‹€æ…‹ï¼šåœæ­¢
                } else {
                    const dirThreshold = 0.05; 
                    if (Math.abs(dx) > Math.abs(dy)) {
                        // æ°´å¹³ (ç¦ç”¨)
                    } else {
                        if (dy < -dirThreshold) handMoveForward = true;
                        else if (dy > dirThreshold) handMoveBackward = true;
                    }
                }
            }

            // 3. å³æ‰‹ (å°„æ“Š)
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.rightHandLandmarks, {color: '#FF0000', lineWidth: 1});

                const indexTip = results.rightHandLandmarks[8];
                const thumbTip = results.rightHandLandmarks[4];
                const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                if (distance < 0.05) isPinching = true;
            }
            canvasCtx.restore();
        }

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        holistic.onResults(onResults);

        function init() {
            const startBtn = document.getElementById('start-btn');
            const loadingText = document.getElementById('loading');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 10, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            camera.position.set(0, player.height, 90);
            camera.lookAt(0, player.height, -100); 

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const gunGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.6);
            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeometry, gunMaterial);
            gun.position.set(0.3, -0.3, -0.5);
            camera.add(gun);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // éµç›¤ç›£è½äº‹ä»¶ï¼šåŒ…å«æ–¹å‘éµå’Œç©ºç™½éµ
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'ArrowUp': keyLookUp = true; break;
                    case 'ArrowDown': keyLookDown = true; break;
                    case 'ArrowLeft': keyLookLeft = true; break;
                    case 'ArrowRight': keyLookRight = true; break;
                    case 'Space': camera.rotation.set(0, 0, 0); break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch(event.code) {
                    case 'ArrowUp': keyLookUp = false; break;
                    case 'ArrowDown': keyLookDown = false; break;
                    case 'ArrowLeft': keyLookLeft = false; break;
                    case 'ArrowRight': keyLookRight = false; break;
                }
            });

            startBtn.addEventListener('click', () => {
                startBtn.disabled = true;
                startBtn.innerText = "å•Ÿå‹•æ”å½±æ©Ÿä¸­...";
                cameraUtils = new Camera(videoElement, {
                    onFrame: async () => { await holistic.send({image: videoElement}); },
                    width: 320, height: 240
                });
                cameraUtils.start().then(() => {
                    document.getElementById('start-screen').style.display = 'none';
                    document.getElementById('ui-container').style.display = 'flex';
                    isGameActive = true;
                }).catch(err => {
                    console.error(err);
                    alert("ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ: " + err);
                    startBtn.disabled = false;
                    startBtn.innerText = "é‡è©¦";
                });
            });

            generateSchool();
            
            loadingText.style.display = 'none';
            startBtn.style.display = 'block';

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // [ä¿®æ”¹] æ–‡å­—ç´‹ç†ç”Ÿæˆå™¨ï¼Œæ”¯æ´è‡ªå‹•æ›è¡Œ
        function createTextTexture(text, bgColor, textColor = 'white') {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 10; ctx.strokeStyle = '#ffffff'; ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            const fontSize = 28; // ç¨å¾®èª¿å°ä¸€é»
            ctx.font = `bold ${fontSize}px "Microsoft JhengHei", Arial`;
            ctx.fillStyle = textColor; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            // è‡ªå‹•æ›è¡Œé‚è¼¯
            const maxWidth = canvas.width - 20;
            const words = text.split(''); // ä¸­æ–‡ä¾å­—å…ƒåˆ†å‰²
            let line = '';
            let lines = [];
            
            for(let n = 0; n < words.length; n++) {
                const testLine = line + words[n];
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n];
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            const lineHeight = fontSize + 5;
            const totalHeight = lines.length * lineHeight;
            const startY = (canvas.height - totalHeight) / 2 + lineHeight / 2;

            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createTileTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f5e6d3'; ctx.fillRect(0, 0, 64, 64);
            ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 2; ctx.strokeRect(0, 0, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // --- åœ°åœ–ç”Ÿæˆ ---
        function generateSchool() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee }); 
            const ceilingMat = new THREE.MeshStandardMaterial({ color: 0xdddddd }); 
            
            const floorTexture = createTileTexture();
            floorTexture.repeat.set(HALLWAY_WIDTH / 2, HALLWAY_LENGTH / 2); 
            const floorMat = new THREE.MeshStandardMaterial({ map: floorTexture });

            const floorGeo = new THREE.PlaneGeometry(HALLWAY_WIDTH, HALLWAY_LENGTH);
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2; floor.position.set(0, 0, 0); 
            scene.add(floor); collidableMeshList.push(floor);

            const ceil = new THREE.Mesh(floorGeo, ceilingMat);
            ceil.rotation.x = Math.PI / 2; ceil.position.set(0, 5, 0);
            scene.add(ceil);

            const wallLength = HALLWAY_LENGTH;
            const wallHeight = 5;
            const wallGeo = new THREE.BoxGeometry(1, wallHeight, wallLength);
            
            const leftWall = new THREE.Mesh(wallGeo, wallMat);
            leftWall.position.set(-HALLWAY_WIDTH/2 - 0.5, wallHeight/2, 0);
            leftWall.userData = { isWall: true };
            scene.add(leftWall); collidableMeshList.push(leftWall);

            const rightWall = new THREE.Mesh(wallGeo, wallMat);
            rightWall.position.set(HALLWAY_WIDTH/2 + 0.5, wallHeight/2, 0);
            rightWall.userData = { isWall: true };
            scene.add(rightWall); collidableMeshList.push(rightWall);

            const endWallGeo = new THREE.BoxGeometry(HALLWAY_WIDTH + 2, wallHeight, 1);
            const startWall = new THREE.Mesh(endWallGeo, wallMat);
            startWall.position.set(0, wallHeight/2, HALLWAY_LENGTH/2);
            startWall.userData = { isWall: true };
            scene.add(startWall); collidableMeshList.push(startWall);

            const endWall = new THREE.Mesh(endWallGeo, wallMat);
            endWall.position.set(0, wallHeight/2, -HALLWAY_LENGTH/2);
            endWall.userData = { isWall: true };
            scene.add(endWall); collidableMeshList.push(endWall);

            for(let z = 80; z > -100; z -= 40) {
                const light = new THREE.PointLight(0xffaa00, 0.5, 30);
                light.position.set(0, 4, z); scene.add(light);
            }

            spawnHallwayEntities();
        }

        function spawnHallwayEntities() {
            const shuffledBad = [...BAD_HABITS].sort(() => 0.5 - Math.random());
            const shuffledGood = [...GOOD_HABITS].sort(() => 0.5 - Math.random());

            const chestPositionsZ = [50, 0, -50];
            
            for (let i = 0; i < 3; i++) {
                const habit = shuffledGood[i % shuffledGood.length];
                const randomX = (Math.random() - 0.5) * (HALLWAY_WIDTH - 4); 
                createChest(randomX, 0, chestPositionsZ[i], habit); 
            }

            const enemyZ = 0; 
            const badHabit = shuffledBad[0];
            createEnemy(0, 0, enemyZ, badHabit);
        }

        function createEnemy(x, y, z, habitName) {
            const enemyGroup = new THREE.Group();
            enemyGroup.position.set(x, y, z);

            const bodyGeometry = new THREE.BoxGeometry(3, 3, 3);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xd32f2f }); 
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 1.5, 0); 
            enemyGroup.add(body);

            const hornGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const hornMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); 

            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(-1, 3.5, 0); leftHorn.rotation.z = Math.PI / 6; 
            enemyGroup.add(leftHorn);

            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(1, 3.5, 0); rightHorn.rotation.z = -Math.PI / 6; 
            enemyGroup.add(rightHorn);
            
            const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.8, 2, 1.5); 
            enemyGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.8, 2, 1.5); 
            enemyGroup.add(rightEye);

            const spriteMap = createTextTexture(habitName, "rgba(255,255,255,0.7)", "black");
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap });
            const label = new THREE.Sprite(spriteMaterial);
            label.position.set(0, 4.5, 0); label.scale.set(6, 3, 1);
            enemyGroup.add(label);

            scene.add(enemyGroup);
            enemies.push({ mesh: enemyGroup, hp: 3, speed: (3 + Math.random() * 2) / 4, lastAttack: 0 });
        }

        function createChest(x, y, z, habitData) {
            const [name, effect, color] = habitData;
            
            const chestGroup = new THREE.Group();
            chestGroup.position.set(x, y, z);

            const bodyGeometry = new THREE.BoxGeometry(2, 1.2, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.6, 0); chestGroup.add(body);

            const lidGeometry = new THREE.BoxGeometry(2.1, 0.6, 2.1);
            const darkerColor = new THREE.Color(color).multiplyScalar(0.8);
            const lidMaterial = new THREE.MeshStandardMaterial({ color: darkerColor, metalness: 0.5, roughness: 0.1 });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.set(0, 1.5, 0); chestGroup.add(lid);

            const lockGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.2);
            const lockMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.8, roughness: 0.2 });
            const lock = new THREE.Mesh(lockGeometry, lockMaterial);
            lock.position.set(0, 1.2, 1.05); chestGroup.add(lock);
            
            const spriteMap = createTextTexture(name, "rgba(255,255,255,0.7)", "black");
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap });
            const label = new THREE.Sprite(spriteMaterial);
            label.position.set(0, 2.5, 0); label.scale.set(4, 2, 1);
            chestGroup.add(label);

            chestGroup.userData = { type: effect, name: name, initialX: x, moveSpeed: 1 + Math.random(), moveRange: 3 };
            scene.add(chestGroup); chests.push(chestGroup);
        }

        function shoot() {
            if (!isGameActive) return;
            const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            bullet.position.copy(camera.position);
            const vector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            bullet.position.addScaledVector(vector, 0.5);
            bullet.userData = { velocity: vector.multiplyScalar(40), lifetime: 2.0 };
            scene.add(bullet); bullets.push(bullet);
            camera.rotation.x += 0.02;
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.addScaledVector(b.userData.velocity, delta);
                b.userData.lifetime -= delta;
                const bulletBox = new THREE.Box3().setFromObject(b);
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (bulletBox.intersectsBox(new THREE.Box3().setFromObject(e.mesh))) {
                        e.hp -= player.damageMultiplier;
                        e.mesh.position.addScaledVector(b.userData.velocity.clone().normalize(), 0.5);
                        hit = true;
                        if (e.hp <= 0) {
                            scene.remove(e.mesh); enemies.splice(j, 1);
                            player.score += 100; updateHUD(); showMessage("æ¶ˆæ»…éŒ¯èª¤è§€å¿µ!", "#4caf50");
                        } else {
                             const bodyMesh = e.mesh.children.find(child => child.geometry.type === 'BoxGeometry' && child.position.y === 1.5);
                             if (bodyMesh) {
                                 bodyMesh.material.color.setHex(0xffffff);
                                 setTimeout(() => bodyMesh.material.color.setHex(0xd32f2f), 50); 
                             }
                        }
                        break;
                    }
                }
                if (hit || b.userData.lifetime <= 0) { scene.remove(b); bullets.splice(i, 1); }
            }
        }

        function updateEnemies(delta) {
            const playerPos = camera.position;
            enemies.forEach(e => {
                const dist = e.mesh.position.distanceTo(playerPos);
                if (dist < 40 && dist > 1.0) {
                    const oldPos = e.mesh.position.clone();
                    e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
                    e.mesh.translateZ(e.speed * delta);
                    if (checkEnemyCollision(e.mesh)) e.mesh.position.copy(oldPos);
                }
                if (dist < 2.5) { 
                    const now = performance.now();
                    if (now - e.lastAttack > 1000) { takeDamage(10); e.lastAttack = now; }
                }
            });
        }

        function checkEnemyCollision(enemyMesh) {
            const r = 1.2; 
            const pos = enemyMesh.position;
            const box = new THREE.Box3(new THREE.Vector3(pos.x-r, pos.y, pos.z-r), new THREE.Vector3(pos.x+r, pos.y+4, pos.z+r));
            for (const mesh of collidableMeshList) {
                if (mesh.userData.isWall && box.intersectsBox(new THREE.Box3().setFromObject(mesh))) return true;
            }
            return false;
        }

        function updateChests(delta) {
            const playerBox = new THREE.Box3().setFromObject(camera); playerBox.expandByScalar(0.5);
            const time = performance.now() / 1000;
            for (let i = chests.length - 1; i >= 0; i--) {
                const c = chests[i]; 
                c.position.x = c.userData.initialX + Math.sin(time * c.userData.moveSpeed) * c.userData.moveRange;

                if (playerBox.intersectsBox(new THREE.Box3().setFromObject(c))) {
                    applyBuff(c.userData.type, c.userData.name); scene.remove(c); chests.splice(i, 1);
                    
                    chestsCollected++;
                    updateHUD();
                    if (chestsCollected >= 3) {
                        gameWin();
                    }
                }
            }
        }

        function applyBuff(type, name) {
            showMessage(`ç²å¾—: ${name}`, "#00ffff");
            if (type === 'speed') { player.speedMultiplier = 2.0; document.getElementById('buff-text').innerText = "åŠ é€Ÿä¸­"; setTimeout(() => { player.speedMultiplier = 1.0; document.getElementById('buff-text').innerText = "ç„¡"; }, 5000); }
            else if (type === 'damage') { player.damageMultiplier = 3.0; document.getElementById('buff-text').innerText = "æ”»æ“Šæå‡"; setTimeout(() => { player.damageMultiplier = 1.0; document.getElementById('buff-text').innerText = "ç„¡"; }, 5000); }
            else if (type === 'invincible') { player.isInvincible = true; document.getElementById('buff-text').innerText = "ç„¡æ•µæ™‚é–“"; document.getElementById('buff-text').style.color = "gold"; setTimeout(() => { player.isInvincible = false; document.getElementById('buff-text').innerText = "ç„¡"; document.getElementById('buff-text').style.color = "#00ff00";}, 5000); }
            else if (type === 'heal') { player.hp = Math.min(player.hp + 30, player.maxHp); updateHUD(); }
        }

        function takeDamage(amount) {
            if (player.isInvincible) return;
            player.hp -= amount; updateHUD();
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.5; setTimeout(() => overlay.style.opacity = 0, 100);
            if (player.hp <= 0) gameOver();
        }

        function checkWallCollision() {
            const r = 0.5; const pos = camera.position;
            const playerBox = new THREE.Box3(new THREE.Vector3(pos.x-r, pos.y-player.height+0.1, pos.z-r), new THREE.Vector3(pos.x+r, pos.y, pos.z+r));
            for (const mesh of collidableMeshList) {
                if (mesh.userData.isWall && playerBox.intersectsBox(new THREE.Box3().setFromObject(mesh))) return true;
            }
            return false;
        }

        function checkTeleporters() {
            // ç„¡
        }

        function updateHUD() {
            document.getElementById('hp-text').innerText = Math.floor(player.hp);
            document.getElementById('hp-bar').style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            document.getElementById('score-text').innerText = chestsCollected;
        }

        function showMessage(text, color) {
            const el = document.getElementById('message-area');
            el.innerText = text; el.style.color = color; el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        function gameOver() {
            isGameOver = true; isGameActive = false;
            document.getElementById('start-screen').innerHTML = `<h1 style="color:red">GAME OVER</h1><p>æœ€çµ‚åˆ†æ•¸: ${player.score}</p><button onclick="location.reload()">é‡æ–°é–‹å§‹</button>`;
            document.getElementById('start-screen').style.display = 'flex';
        }

        function gameWin() {
            isGameOver = true; isGameActive = false;
            document.getElementById('start-screen').innerHTML = `
                <h1 style="color:#4caf50">æ­å–œé€šé—œï¼</h1>
                <p>é›†é½Š 3 å€‹æ­£ç¢ºä½¿ç”¨ AI å­¸ç¿’çš„è§€å¿µï¼</p>
                <p>ä½ å·²è£å‚™å¥½ç”Ÿæˆå¼äººå·¥æ™ºèƒ½é€™å€‹å­¸ç¿’åˆ©å™¨ï¼</p>
                <p>æœ€çµ‚åˆ†æ•¸: ${player.score}</p>
                <button onclick="location.reload()">å†æ¬¡æŒ‘æˆ°</button>
            `;
            document.getElementById('start-screen').style.display = 'flex';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameActive && !isGameOver) {
                const time = performance.now(); const delta = (time - prevTime) / 1000;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 20.0 * delta; 

                direction.z = Number(handMoveForward) - Number(handMoveBackward);
                direction.x = 0; 
                direction.normalize(); 

                const speed = 50.0 * player.speedMultiplier;
                if (handMoveForward || handMoveBackward) velocity.z -= direction.z * speed * delta;

                // [ä¿®æ”¹] éµç›¤è¼”åŠ©ç„æº–
                const keySpeed = 1.5;
                if (keyLookLeft) camera.rotation.y += keySpeed * delta;
                if (keyLookRight) camera.rotation.y -= keySpeed * delta;
                if (keyLookUp) camera.rotation.x += keySpeed * delta; // æŠ¬é ­ (å¢åŠ Xè»¸è§’åº¦ï¼Œè¦–é‚è¼¯èª¿æ•´)
                if (keyLookDown) camera.rotation.x -= keySpeed * delta; // ä½é ­

                const rotSpeed = 2.0 * delta;
                camera.rotation.y -= headLookYaw * rotSpeed;
                camera.rotation.x -= headLookPitch * rotSpeed;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));

                if (isPinching && !wasPinching) shoot();
                wasPinching = isPinching;

                const oldPos = camera.position.clone();
                const moveVec = new THREE.Vector3();
                if (velocity.x !== 0) {
                    const sideDir = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    sideDir.y = 0; sideDir.normalize();
                    moveVec.addScaledVector(sideDir, velocity.x * delta);
                }
                if (velocity.z !== 0) {
                    const fwdDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    fwdDir.y = 0; fwdDir.normalize();
                    moveVec.addScaledVector(fwdDir, -velocity.z * delta);
                }
                
                camera.position.x += moveVec.x; camera.position.z += moveVec.z;
                if (checkWallCollision()) {
                    const tempPos = camera.position.clone();
                    camera.position.z = oldPos.z;
                    if (checkWallCollision()) {
                        camera.position.z = tempPos.z; camera.position.x = oldPos.x;
                        if (checkWallCollision()) camera.position.copy(oldPos);
                    }
                }
                
                camera.position.y += velocity.y * delta; 
                // ç°¡å–®åœ°é¢ç¢°æ’
                if (camera.position.y < player.height) {
                    velocity.y = 0; camera.position.y = player.height;
                }

                updateBullets(delta); updateEnemies(delta); updateChests(delta); checkTeleporters();
                prevTime = time;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
