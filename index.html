<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Learning Shooter - Hallway Challenge</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Noto Sans TC', sans-serif; user-select: none; }
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            z-index: 5;
        }
        #hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            color: white; text-shadow: 2px 2px 0 #000; font-size: 24px; font-weight: bold;
        }
        #hud-bottom {
            padding: 20px; color: white; text-shadow: 1px 1px 0 #000; font-size: 18px;
            text-align: center;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            background: transparent;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: red;
            transform: translate(-50%, -50%); border-radius: 50%;
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 10;
        }
        button {
            padding: 15px 30px; font-size: 24px; cursor: pointer;
            background: #4CAF50; color: white; border: none; border-radius: 5px;
            margin-top: 20px;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        .message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ffeb3b; font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px #000;
            opacity: 0; transition: opacity 0.5s;
        }
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s;
            z-index: 4;
        }
        .bar-container {
            width: 200px; height: 20px; background: #333; border: 2px solid white; margin-bottom: 5px;
        }
        #hp-bar { width: 100%; height: 100%; background: #f44336; transition: width 0.2s; }
        
        /* Loading Text */
        #loading { font-size: 20px; color: #aaa; margin-top: 10px; }

        /* MediaPipe Debug View */
        #mediapipe-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 320px; height: 240px;
            border: 2px solid white; background: black;
            z-index: 6; transform: scaleX(-1); /* é¡åƒé¡¯ç¤º */
        }
        #input_video { display: none; }
        #output_canvas { width: 100%; height: 100%; }
        
        .instruction-overlay {
            position: absolute; top: 50%; left: 20px; transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.7); font-size: 14px; pointer-events: none;
            text-align: left;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <!-- Import Map to resolve 'three' dependency -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe Libraries (Switch to Holistic) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- UI Overlay -->
    <div id="damage-overlay"></div>
    <div id="ui-container">
        <div id="hud-top">
            <div>
                <div class="bar-container"><div id="hp-bar"></div></div>
                <div>HP: <span id="hp-text">100</span></div>
            </div>
            <div>å¯¶ç®±: <span id="score-text">0</span> / 3</div>
        </div>
        <div id="message-area" class="message"></div>
        <div id="hud-bottom">
            <div>ç‹€æ…‹: <span id="buff-text" style="color:#00ff00;">ç„¡</span></div>
            <div style="font-size: 14px; color: #ccc;">é ­éƒ¨è½‰å‹•ç„æº– | å·¦æ‰‹æ‰‹æŒ‡æŒ‡å‘ç§»å‹• | å³æ‰‹æåˆå°„æ“Š</div>
        </div>
        <div class="instruction-overlay">
            <p>ğŸ™‚ <b>é ­éƒ¨ (ç„æº–)</b></p>
            <p>é ­éƒ¨è½‰å‘/ç§»å‹•: æ§åˆ¶æº–å¿ƒ</p>
            <p>ä¿æŒé ­éƒ¨åœ¨ä¸­å¤®åå­—: åœæ­¢æ—‹è½‰</p>
            <br>
            <p>ğŸ–ï¸ <b>å·¦æ‰‹ (ç§»å‹•)</b></p>
            <p>â˜ï¸ æ‰‹æŒ‡æŒ‡å‘ä¸Š: å‰é€²</p>
            <p>ğŸ‘‡ æ‰‹æŒ‡æŒ‡å‘ä¸‹: å¾Œé€€</p>
            <p>âœŠ æ¡æ‹³: åœæ­¢ç§»å‹•</p>
            <br>
            <p>ğŸ–ï¸ <b>å³æ‰‹ (æ”»æ“Š)</b></p>
            <p>ğŸ‘Œ æåˆ: å°„æ“Š</p>
        </div>
    </div>
    <div id="crosshair"></div>

    <!-- MediaPipe Container -->
    <div id="mediapipe-container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>å–„ç”¨ AI å­¸ç¿’ - é•·å»ŠæŒ‘æˆ°</h1>
        <p>é€™æ˜¯ä¸€æ¢å……æ»¿è€ƒé©—çš„é•·èµ°å»Š</p>
        <p>æ”¶é›†æ²¿é€”çš„ 3 å€‹å¯¶ç®±ï¼Œä¸¦æ“Šæ•—å®ˆè¡›æ€ªç‰©</p>
        <div id="loading">è¼‰å…¥ç¥ç¶“ç¶²çµ¡æ¨¡å‹ä¸­... (è«‹ç¨å€™)</div>
        <button id="start-btn" style="display:none;">é–‹å•Ÿæ”å½±æ©Ÿä¸¦é–‹å§‹</button>
    </div>

    <!-- Scripts -->
    <script type="module">
        import * as THREE from 'three';

        // --- éŠæˆ²å¸¸æ•¸èˆ‡è®Šæ•¸ ---
        const HALLWAY_WIDTH = 12;
        const HALLWAY_LENGTH = 200; 
        
        const BAD_HABITS = ["ç›´æ¥æŠ„è¥²", "ä¸åšæŸ¥è­‰", "æ´©éœ²éš±ç§", "åœæ­¢æ€è€ƒ", "ç›²ç›®ç›¸ä¿¡", "éåº¦ä¾è³´", "å¿½è¦–ç‰ˆæ¬Š"];
        const GOOD_HABITS = [
            ["è¼”åŠ©æ€è€ƒ", "speed", "#00ffff"], ["æª¢æŸ¥ä¾†æº", "damage", "#ff00ff"],
            ["å„ªåŒ–èªæ³•", "heal", "#00ff00"], ["æ¿€ç™¼å‰µæ„", "invincible", "#ffd700"],
            ["è§£é‡‹ä»£ç¢¼", "heal", "#00ff00"]
        ];

        let camera, scene, renderer;
        
        // æ“æ§è®Šæ•¸
        let handMoveForward = false, handMoveBackward = false, handMoveLeft = false, handMoveRight = false;
        let headLookYaw = 0;   
        let headLookPitch = 0; 
        let isPinching = false;
        let wasPinching = false;
        
        let prevTime = performance.now();
        let isGameOver = false; 
        let isGameActive = false; 
        let chestsCollected = 0; 
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        const bullets = [];
        const enemies = [];
        const chests = [];
        const collidableMeshList = []; 
        
        const player = {
            hp: 100, maxHp: 100, score: 0,
            speedMultiplier: 1.0, damageMultiplier: 1.0,
            isInvincible: false, height: 1.6
        };

        // --- MediaPipe Holistic åˆå§‹åŒ– ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        let cameraUtils = null;

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            const w = canvasElement.width;
            const h = canvasElement.height;
            canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            canvasCtx.lineWidth = 1;
            canvasCtx.beginPath(); canvasCtx.moveTo(w / 2, 0); canvasCtx.lineTo(w / 2, h); canvasCtx.stroke();
            canvasCtx.beginPath(); canvasCtx.moveTo(0, h / 2); canvasCtx.lineTo(w, h / 2); canvasCtx.stroke();

            handMoveForward = false; handMoveBackward = false;
            handMoveLeft = false; handMoveRight = false;
            headLookYaw = 0; headLookPitch = 0;
            isPinching = false;

            // 1. é ­éƒ¨è¿½è¹¤
            if (results.faceLandmarks) {
                const nose = results.faceLandmarks[1];
                const nx = nose.x * canvasElement.width;
                const ny = nose.y * canvasElement.height;
                canvasCtx.beginPath(); canvasCtx.arc(nx, ny, 5, 0, 2 * Math.PI); canvasCtx.fillStyle = "yellow"; canvasCtx.fill();

                const deadzone = 0.05;
                if (nose.x < 0.5 - deadzone) headLookYaw = 1.2 * (0.5 - deadzone - nose.x) * 10; 
                else if (nose.x > 0.5 + deadzone) headLookYaw = -1.2 * (nose.x - 0.5 - deadzone) * 10;
                
                if (nose.y < 0.5 - deadzone) headLookPitch = -0.4 * (0.5 - deadzone - nose.y) * 10; 
                else if (nose.y > 0.5 + deadzone) headLookPitch = 0.4 * (nose.y - 0.5 - deadzone) * 10; 
            }

            // 2. å·¦æ‰‹ (ç§»å‹•)
            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.leftHandLandmarks, {color: '#00FF00', lineWidth: 1});

                const wrist = results.leftHandLandmarks[0];
                const indexTip = results.leftHandLandmarks[8];
                const dx = indexTip.x - wrist.x;
                const dy = indexTip.y - wrist.y;
                const dist = Math.hypot(dx, dy);
                const fistThreshold = 0.08; 

                if (dist < fistThreshold) {
                    // æ¡æ‹³ç‹€æ…‹ï¼šåœæ­¢
                } else {
                    const dirThreshold = 0.05; 
                    if (Math.abs(dx) > Math.abs(dy)) {
                        // æ°´å¹³ (ç¦ç”¨)
                    } else {
                        if (dy < -dirThreshold) handMoveForward = true;
                        else if (dy > dirThreshold) handMoveBackward = true;
                    }
                }
            }

            // 3. å³æ‰‹ (å°„æ“Š)
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.rightHandLandmarks, {color: '#FF0000', lineWidth: 1});

                const indexTip = results.rightHandLandmarks[8];
                const thumbTip = results.rightHandLandmarks[4];
                const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                if (distance < 0.05) isPinching = true;
            }
            canvasCtx.restore();
        }

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        holistic.onResults(onResults);

        function init() {
            const startBtn = document.getElementById('start-btn');
            const loadingText = document.getElementById('loading');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 10, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            camera.position.set(0, player.height, 90);
            camera.lookAt(0, player.height, -100); 

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const gunGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.6);
            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeometry, gunMaterial);
            gun.position.set(0.3, -0.3, -0.5);
            camera.add(gun);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            startBtn.addEventListener('click', () => {
                startBtn.disabled = true;
                startBtn.innerText = "å•Ÿå‹•æ”å½±æ©Ÿä¸­...";
                cameraUtils = new Camera(videoElement, {
                    onFrame: async () => { await holistic.send({image: videoElement}); },
                    width: 320, height: 240
                });
                cameraUtils.start().then(() => {
                    document.getElementById('start-screen').style.display = 'none';
                    document.getElementById('ui-container').style.display = 'flex';
                    isGameActive = true;
                }).catch(err => {
                    console.error(err);
                    alert("ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ: " + err);
                    startBtn.disabled = false;
                    startBtn.innerText = "é‡è©¦";
                });
            });

            generateSchool();
            
            loadingText.style.display = 'none';
            startBtn.style.display = 'block';

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createTextTexture(text, bgColor, textColor = 'white') {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 10; ctx.strokeStyle = '#ffffff'; ctx.strokeRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 36px "Microsoft JhengHei", Arial';
            ctx.fillStyle = textColor; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            return new THREE.CanvasTexture(canvas);
        }

        // --- åœ°åœ–ç”Ÿæˆ ---
        function generateSchool() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee }); 
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 }); 
            const ceilingMat = new THREE.MeshStandardMaterial({ color: 0xdddddd }); 

            // åœ°æ¿èˆ‡å¤©èŠ±æ¿ (é•·åº¦ç¯„åœ: Z = 100 åˆ° -100)
            const floorGeo = new THREE.PlaneGeometry(HALLWAY_WIDTH, HALLWAY_LENGTH);
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2; 
            floor.position.set(0, 0, 0); 
            scene.add(floor); collidableMeshList.push(floor);

            const ceil = new THREE.Mesh(floorGeo, ceilingMat);
            ceil.rotation.x = Math.PI / 2; 
            ceil.position.set(0, 5, 0);
            scene.add(ceil);

            // å…©å´ç‰†å£ (å…¨é•·å¯¦å¿ƒç‰†)
            const wallLength = HALLWAY_LENGTH;
            const wallHeight = 5;
            const wallGeo = new THREE.BoxGeometry(1, wallHeight, wallLength);
            
            const leftWall = new THREE.Mesh(wallGeo, wallMat);
            leftWall.position.set(-HALLWAY_WIDTH/2 - 0.5, wallHeight/2, 0);
            leftWall.userData = { isWall: true };
            scene.add(leftWall); collidableMeshList.push(leftWall);

            const rightWall = new THREE.Mesh(wallGeo, wallMat);
            rightWall.position.set(HALLWAY_WIDTH/2 + 0.5, wallHeight/2, 0);
            rightWall.userData = { isWall: true };
            scene.add(rightWall); collidableMeshList.push(rightWall);

            const endWallGeo = new THREE.BoxGeometry(HALLWAY_WIDTH + 2, wallHeight, 1);
            
            const startWall = new THREE.Mesh(endWallGeo, wallMat);
            startWall.position.set(0, wallHeight/2, HALLWAY_LENGTH/2);
            startWall.userData = { isWall: true };
            scene.add(startWall); collidableMeshList.push(startWall);

            const endWall = new THREE.Mesh(endWallGeo, wallMat);
            endWall.position.set(0, wallHeight/2, -HALLWAY_LENGTH/2);
            endWall.userData = { isWall: true };
            scene.add(endWall); collidableMeshList.push(endWall);

            for(let z = 80; z > -100; z -= 40) {
                const light = new THREE.PointLight(0xffaa00, 0.5, 30);
                light.position.set(0, 4, z); scene.add(light);
            }

            spawnHallwayEntities();
        }

        function spawnHallwayEntities() {
            const shuffledBad = [...BAD_HABITS].sort(() => 0.5 - Math.random());
            const shuffledGood = [...GOOD_HABITS].sort(() => 0.5 - Math.random());

            const chestPositionsZ = [50, 0, -50];
            
            for (let i = 0; i < 3; i++) {
                const habit = shuffledGood[i % shuffledGood.length];
                // [ä¿®æ”¹] éš¨æ©Ÿ X ä½ç½® (ç¯„åœ -4 åˆ° 4ï¼Œèµ°å»Šå¯¬åº¦çš„ä¸€åŠæ¸›å»ä¸€äº›é‚Šè·)
                const randomX = (Math.random() - 0.5) * 8; 
                createChest(randomX, 0, chestPositionsZ[i], habit); 
            }

            // [ä¿®æ”¹] æ€ªç‰©ä½ç½®ç§»åˆ°æœ€ä¸­é–“ (Z=0)
            const enemyZ = 0; 
            const badHabit = shuffledBad[0];
            createEnemy(0, 0, enemyZ, badHabit);
        }

        function createEnemy(x, y, z, habitName) {
            // [ä¿®æ”¹] æ€ªç‰©è®Šå¤§ 1 å€ (3x3x3)
            const enemy = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshStandardMaterial({ map: createTextTexture(habitName, '#d32f2f') }));
            // y èª¿æ•´é«˜åº¦ (1.5)
            enemy.position.set(x, y + 1.5, z); 
            scene.add(enemy);
            // [ä¿®æ”¹] é€Ÿåº¦å†æ…¢ä¸€é» (é™¤ä»¥ 4)
            enemies.push({ mesh: enemy, hp: 3, speed: (3 + Math.random() * 2) / 4, lastAttack: 0 });
        }

        function createChest(x, y, z, habitData) {
            const [name, effect, color] = habitData;
            // [ä¿®æ”¹] å¯¶ç®±å¤§å°è®Šå¤§ 1 å€ (2x2x2) å’Œå­—é«”ç™½è‰² (#ffffff)
            const chest = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({ map: createTextTexture(name, color, '#ffffff'), metalness: 0.5, roughness: 0.1 }));
            // Y è»¸é«˜åº¦èª¿æ•´ (1.0)
            chest.position.set(x, y + 1.0, z); 
            // [æ–°å¢] å·¦å³ç§»å‹•å±¬æ€§
            chest.userData = { type: effect, name: name, initialX: x, moveSpeed: 1 + Math.random(), moveRange: 3 };
            scene.add(chest); chests.push(chest);
        }

        function shoot() {
            if (!isGameActive) return;
            const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            bullet.position.copy(camera.position);
            const vector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            bullet.position.addScaledVector(vector, 0.5);
            bullet.userData = { velocity: vector.multiplyScalar(40), lifetime: 2.0 };
            scene.add(bullet); bullets.push(bullet);
            camera.rotation.x += 0.02;
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.addScaledVector(b.userData.velocity, delta);
                b.userData.lifetime -= delta;
                const bulletBox = new THREE.Box3().setFromObject(b);
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (bulletBox.intersectsBox(new THREE.Box3().setFromObject(e.mesh))) {
                        e.hp -= player.damageMultiplier;
                        e.mesh.position.addScaledVector(b.userData.velocity.clone().normalize(), 0.5);
                        hit = true;
                        if (e.hp <= 0) {
                            scene.remove(e.mesh); enemies.splice(j, 1);
                            player.score += 100; updateHUD(); showMessage("æ¶ˆæ»…éŒ¯èª¤è§€å¿µ!", "#4caf50");
                        } else {
                             e.mesh.material.color.setHex(0xffffff);
                             setTimeout(() => e.mesh.material.color.setHex(0xffffff), 50); 
                        }
                        break;
                    }
                }
                if (hit || b.userData.lifetime <= 0) { scene.remove(b); bullets.splice(i, 1); }
            }
        }

        function updateEnemies(delta) {
            const playerPos = camera.position;
            enemies.forEach(e => {
                const dist = e.mesh.position.distanceTo(playerPos);
                if (dist < 40 && dist > 1.0) {
                    const oldPos = e.mesh.position.clone();
                    e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
                    e.mesh.translateZ(e.speed * delta);
                    if (checkEnemyCollision(e.mesh)) e.mesh.position.copy(oldPos);
                }
                if (dist < 2.5) { // æ”»æ“Šè·é›¢ç¨å¾®å¢åŠ ï¼Œå› ç‚ºé«”å‹è®Šå¤§äº†
                    const now = performance.now();
                    if (now - e.lastAttack > 1000) { takeDamage(10); e.lastAttack = now; }
                }
            });
        }

        function checkEnemyCollision(enemyMesh) {
            const r = 1.2; // å¢åŠ ç¢°æ’åŠå¾‘
            const pos = enemyMesh.position;
            const box = new THREE.Box3(new THREE.Vector3(pos.x-r, pos.y-1.5, pos.z-r), new THREE.Vector3(pos.x+r, pos.y+1.5, pos.z+r));
            for (const mesh of collidableMeshList) {
                if (mesh.userData.isWall && box.intersectsBox(new THREE.Box3().setFromObject(mesh))) return true;
            }
            return false;
        }

        function updateChests(delta) {
            const playerBox = new THREE.Box3().setFromObject(camera); playerBox.expandByScalar(0.5);
            const time = performance.now() / 1000;
            for (let i = chests.length - 1; i >= 0; i--) {
                const c = chests[i]; 
                c.rotation.y += delta;
                // [æ–°å¢] å¯¶ç®±å·¦å³ç§»å‹•
                c.position.x = c.userData.initialX + Math.sin(time * c.userData.moveSpeed) * c.userData.moveRange;

                if (playerBox.intersectsBox(new THREE.Box3().setFromObject(c))) {
                    applyBuff(c.userData.type, c.userData.name); scene.remove(c); chests.splice(i, 1);
                    
                    chestsCollected++;
                    updateHUD();
                    if (chestsCollected >= 3) {
                        gameWin();
                    }
                }
            }
        }

        function applyBuff(type, name) {
            showMessage(`ç²å¾—: ${name}`, "#00ffff");
            if (type === 'speed') { player.speedMultiplier = 2.0; document.getElementById('buff-text').innerText = "åŠ é€Ÿä¸­"; setTimeout(() => { player.speedMultiplier = 1.0; document.getElementById('buff-text').innerText = "ç„¡"; }, 5000); }
            else if (type === 'damage') { player.damageMultiplier = 3.0; document.getElementById('buff-text').innerText = "æ”»æ“Šæå‡"; setTimeout(() => { player.damageMultiplier = 1.0; document.getElementById('buff-text').innerText = "ç„¡"; }, 5000); }
            else if (type === 'invincible') { player.isInvincible = true; document.getElementById('buff-text').innerText = "ç„¡æ•µæ™‚é–“"; document.getElementById('buff-text').style.color = "gold"; setTimeout(() => { player.isInvincible = false; document.getElementById('buff-text').innerText = "ç„¡"; document.getElementById('buff-text').style.color = "#00ff00";}, 5000); }
            else if (type === 'heal') { player.hp = Math.min(player.hp + 30, player.maxHp); updateHUD(); }
        }

        function takeDamage(amount) {
            if (player.isInvincible) return;
            player.hp -= amount; updateHUD();
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.5; setTimeout(() => overlay.style.opacity = 0, 100);
            if (player.hp <= 0) gameOver();
        }

        function checkWallCollision() {
            const r = 0.5; const pos = camera.position;
            const playerBox = new THREE.Box3(new THREE.Vector3(pos.x-r, pos.y-player.height+0.1, pos.z-r), new THREE.Vector3(pos.x+r, pos.y, pos.z+r));
            for (const mesh of collidableMeshList) {
                if (mesh.userData.isWall && playerBox.intersectsBox(new THREE.Box3().setFromObject(mesh))) return true;
            }
            return false;
        }

        function checkTeleporters() {
            // ç„¡
        }

        function updateHUD() {
            document.getElementById('hp-text').innerText = Math.floor(player.hp);
            document.getElementById('hp-bar').style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            document.getElementById('score-text').innerText = chestsCollected;
        }

        function showMessage(text, color) {
            const el = document.getElementById('message-area');
            el.innerText = text; el.style.color = color; el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        function gameOver() {
            isGameOver = true; isGameActive = false;
            document.getElementById('start-screen').innerHTML = `<h1 style="color:red">GAME OVER</h1><p>æœ€çµ‚åˆ†æ•¸: ${player.score}</p><button onclick="location.reload()">é‡æ–°é–‹å§‹</button>`;
            document.getElementById('start-screen').style.display = 'flex';
        }

        function gameWin() {
            isGameOver = true; isGameActive = false;
            document.getElementById('start-screen').innerHTML = `
                <h1 style="color:#4caf50">æ­å–œé€šé—œï¼</h1>
                <p>ä½ å·²ç¶“é›†é½Š 3 å€‹æ­£ç¢ºçš„ AI å­¸ç¿’è§€å¿µï¼</p>
                <p>æœ€çµ‚åˆ†æ•¸: ${player.score}</p>
                <button onclick="location.reload()">å†æ¬¡æŒ‘æˆ°</button>
            `;
            document.getElementById('start-screen').style.display = 'flex';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameActive && !isGameOver) {
                const time = performance.now(); const delta = (time - prevTime) / 1000;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 20.0 * delta; 

                direction.z = Number(handMoveForward) - Number(handMoveBackward);
                direction.x = 0; 
                direction.normalize(); 

                const speed = 50.0 * player.speedMultiplier;
                if (handMoveForward || handMoveBackward) velocity.z -= direction.z * speed * delta;

                const rotSpeed = 2.0 * delta;
                camera.rotation.y -= headLookYaw * rotSpeed;
                camera.rotation.x -= headLookPitch * rotSpeed;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));

                if (isPinching && !wasPinching) shoot();
                wasPinching = isPinching;

                const oldPos = camera.position.clone();
                const moveVec = new THREE.Vector3();
                if (velocity.x !== 0) {
                    const sideDir = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    sideDir.y = 0; sideDir.normalize();
                    moveVec.addScaledVector(sideDir, velocity.x * delta);
                }
                if (velocity.z !== 0) {
                    const fwdDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    fwdDir.y = 0; fwdDir.normalize();
                    moveVec.addScaledVector(fwdDir, -velocity.z * delta);
                }
                
                camera.position.x += moveVec.x; camera.position.z += moveVec.z;
                if (checkWallCollision()) {
                    const tempPos = camera.position.clone();
                    camera.position.z = oldPos.z;
                    if (checkWallCollision()) {
                        camera.position.z = tempPos.z; camera.position.x = oldPos.x;
                        if (checkWallCollision()) camera.position.copy(oldPos);
                    }
                }
                
                camera.position.y += velocity.y * delta; 
                // ç°¡å–®åœ°é¢ç¢°æ’
                if (camera.position.y < player.height) {
                    velocity.y = 0; camera.position.y = player.height;
                }

                updateBullets(delta); updateEnemies(delta); updateChests(delta); checkTeleporters();
                prevTime = time;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
